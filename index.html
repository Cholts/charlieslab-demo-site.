<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="pageTitle">Quaderni di Archeologia della Libya - Publications</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f4; /* neutral-100 for a subtle, aged paper feel */
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        /* Custom modal styles for alerts and book details */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            padding: 1rem; /* Add some padding for smaller screens */
        }
        .modal.flex {
            display: flex; /* Override display: none when showing */
        }
        .modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px; /* Increased max-width for book details */
            width: 90%;
            text-align: center;
            position: relative; /* For positioning close button */
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            line-height: 1; /* Adjust line-height to center X vertically */
            position: absolute;
            top: 10px;
            right: 20px;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        /* Style for book card to allow full description on click */
        .book-card {
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-neutral-100 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-stone-800 shadow-md py-4 px-6 md:px-8">
        <div class="container flex flex-col md:flex-row justify-between items-center gap-y-4 md:gap-y-0 md:gap-x-12">
            <h1 class="text-2xl md:text-3xl font-bold text-neutral-100 text-center md:text-left" data-lang-key="headerTitle">Quaderni di Archeologia della Libya</h1>
            <nav class="flex flex-wrap justify-center md:justify-end items-center space-x-2 md:space-x-4">
                <button id="homeViewBtn" class="bg-stone-600 hover:bg-stone-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="homeBtn">Publications</button>
                <button id="aboutViewBtn" class="bg-stone-600 hover:bg-stone-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="aboutBtn">About Us</button>
                <button id="contactViewBtn" class="bg-stone-600 hover:bg-stone-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="contactBtn">Contact Us</button>
                <!-- Admin login button made less pronounced -->
                <button id="adminLoginBtn" class="text-neutral-300 hover:text-neutral-100 font-semibold py-2 px-2 rounded-lg transition duration-300 text-sm transform hover:scale-105" data-lang-key="adminLoginBtn">Admin Login</button>
                
                <!-- Language Toggle -->
                <div class="ml-4 flex space-x-2">
                    <button id="langEnBtn" class="text-neutral-300 hover:text-neutral-100 font-semibold py-1 px-2 rounded-lg text-sm bg-stone-700 transition duration-300 transform hover:scale-110">EN</button>
                    <button id="langItBtn" class="text-neutral-300 hover:text-neutral-100 font-semibold py-1 px-2 rounded-lg text-sm bg-stone-700 transition duration-300 transform hover:scale-110">IT</button>
                </div>
            </nav>
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow container mt-8">

        <!-- Message/Alert Modal -->
        <div id="messageModal" class="modal hidden">
            <div class="modal-content">
                <span class="close-button text-gray-600 hover:text-gray-900 cursor-pointer text-xl mb-4" onclick="closeMessageModal()">&times;</span>
                <p id="modalMessage" class="text-lg text-gray-800"></p>
                <button onclick="closeMessageModal()" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="modalOkBtn">OK</button>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmModal" class="modal hidden">
            <div class="modal-content">
                <p id="confirmMessage" class="text-lg text-gray-800 mb-6"></p>
                <div class="flex justify-center space-x-4">
                    <button id="confirmYesBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="confirmYesBtn">Yes</button>
                    <button id="confirmNoBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="confirmNoBtn">No</button>
                </div>
            </div>
        </div>

        <!-- Book Details Modal -->
        <div id="bookDetailsModal" class="modal hidden">
            <div class="modal-content">
                <span class="close-button text-gray-600 hover:text-gray-900 cursor-pointer text-xl" onclick="closeBookDetailsModal()">&times;</span>
                <img id="modalBookCover" src="" alt="Book Cover" class="w-48 h-64 object-cover rounded-md mx-auto mb-4 shadow-lg">
                <h3 id="modalBookTitle" class="text-2xl font-bold mb-2 text-gray-800"></h3>
                <p id="modalBookAuthor" class="text-gray-600 text-base mb-3"></p>
                <p id="modalBookDescription" class="text-gray-700 text-sm text-left leading-relaxed mb-6"></p>
                <a id="modalDownloadPdfBtn" href="#" target="_blank" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="downloadPdfButton">Download PDF</a>
            </div>
        </div>

        <!-- Home View Section (Publications) -->
        <section id="homeView" class="hidden bg-neutral-50 p-6 rounded-xl shadow-lg">
            <h2 class="text-3xl font-bold mb-6 text-center text-gray-800" data-lang-key="ourPublicationsTitle">Our Publications</h2>
            <div class="mb-6 max-w-lg mx-auto"> <!-- Added max-w-lg mx-auto for better centering and room -->
                <label for="publicSearchInput" class="sr-only" data-lang-key="searchPublicationsLabel">Search Publications</label>
                <input type="text" id="publicSearchInput" placeholder="Search by title or author..." class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200" data-lang-key="searchPlaceholder">
            </div>
            <div id="booksContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                <!-- Books will be loaded here by JavaScript -->
                <p class="text-center text-gray-500 col-span-full" id="noBooksMessage" data-lang-key="noPublicationsMessage">No publications yet. Check back soon!</p>
            </div>
        </section>

        <!-- About Us Section -->
        <section id="aboutView" class="hidden bg-neutral-50 p-6 rounded-xl shadow-lg">
            <h2 class="text-3xl font-bold mb-6 text-center text-gray-800" data-lang-key="aboutTitle">About Quaderni di Archeologia della Libya</h2>
            <div class="prose max-w-none text-gray-700 leading-relaxed space-y-4">
                <p data-lang-key="aboutPara1">Welcome to the official website for <strong>Quaderni di Archeologia della Libya</strong>, a prestigious academic journal dedicated to archaeological research in Libya. Initiated in 1950, this esteemed series documents the significant contributions of Italian archaeological missions in the region, fostering a deeper understanding of its rich ancient history.</p>
                <p data-lang-key="aboutPara2">After a brief hiatus, the journal proudly resumed publication in 2018 with a new series, re-establishing itself as a leading scientific platform. We provide an essential venue for scholars interested in the archaeology and history of Libya and the broader Maghreb, ensuring high-quality, peer-reviewed content.</p>
                <p data-lang-key="aboutPara3">Our volumes embrace a multidisciplinary approach, featuring articles on epigraphy, ancient and colonial history, the history of archaeology, and territorial studies. Contributions are published in major European languages, complemented by comprehensive English and Arabic abstracts, to promote international academic exchange and collaboration.</p>
                <p data-lang-key="aboutPara4">This website serves as a dedicated resource for the series, maintained by L'Erma di Bretschneider, a renowned academic publishing house in Rome. We are committed to upholding the highest standards of scholarly excellence and ensuring the continued global dissemination of groundbreaking research presented in the "Quaderni di Archeologia della Libya."</p>
            </div>
        </section>

        <!-- Contact Us Section -->
        <section id="contactView" class="hidden bg-neutral-50 p-6 rounded-xl shadow-lg">
            <h2 class="text-3xl font-bold mb-6 text-center text-gray-800" data-lang-key="contactTitle">Contact Us</h2>
            <div class="text-gray-700 space-y-4">
                <p><strong class="font-semibold" data-lang-key="contactEmailLabel">Email:</strong> <a href="mailto:lerma@lerma.it" class="text-blue-600 hover:underline">lerma@lerma.it</a></p>
                <p><strong class="font-semibold" data-lang-key="contactPhoneLabel">Phone:</strong> +39 06 6874127</p>
                <p><strong class="font-semibold" data-lang-key="contactAddressLabel">Address:</strong></p>
                <address class="not-italic">
                    L'Erma di Bretschneider<br>
                    Via Marianna Dionigi, 57<br>
                    00193 Roma RM, Italy
                </address>
                <p data-lang-key="contactMessage">For inquiries regarding publications of "Quaderni di Archeologia della Libya" or other scholarly initiatives, please feel free to reach out to L'Erma di Bretschneider through the contact information provided above.</p>
            </div>
        </section>

        <!-- Admin Login Section -->
        <section id="adminLoginView" class="hidden bg-neutral-50 p-8 rounded-xl shadow-lg max-w-md mx-auto">
            <h2 class="text-3xl font-bold mb-8 text-center text-gray-800" data-lang-key="adminLoginTitle">Admin Login</h2>
            <form id="adminLoginForm" class="space-y-6">
                <div>
                    <label for="username" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="usernameLabel">Username (Email):</label>
                    <input type="email" id="username" name="username" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="password" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="passwordLabel">Password:</label>
                    <input type="password" id="password" name="password" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button type="submit" class="w-full bg-stone-600 hover:bg-stone-700 text-white font-semibold py-3 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="loginButton">Login</button>
            </form>
            <p class="text-center text-sm text-gray-500 mt-4" data-lang-key="firebaseAuthHint">Use your Firebase Auth admin email and password.</p>
            <p class="text-sm text-red-500 mt-2 text-center" id="loginErrorMessage"></p>
        </section>

        <!-- Admin Dashboard Section -->
        <section id="adminDashboardView" class="hidden bg-neutral-50 p-8 rounded-xl shadow-lg">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
                <h2 class="text-3xl font-bold text-gray-800" data-lang-key="adminDashboardTitle">Admin Dashboard</h2>
                <button id="adminLogoutBtn" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="logoutButton">Logout</button>
            </div>

            <!-- Upload/Edit New Book Form -->
            <div class="mb-8 p-6 border border-gray-200 rounded-xl shadow-sm">
                <h3 id="formTitle" class="text-2xl font-bold mb-4 text-gray-800" data-lang-key="uploadNewPublicationTitle">Upload New Publication</h3>
                <form id="uploadBookForm" class="space-y-4">
                    <div>
                        <label for="bookTitle" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="bookTitleLabel">Title:</label>
                        <input type="text" id="bookTitle" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label for="bookAuthor" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="bookAuthorLabel">Author:</label>
                        <input type="text" id="bookAuthor" required class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label for="bookDescription" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="bookDescriptionLabel">Description:</label>
                        <textarea id="bookDescription" rows="3" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                    </div>
                    <div>
                        <label for="coverImageFile" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="uploadCoverImageLabel">Upload Cover Image:</label>
                        <input type="file" id="coverImageFile" accept="image/png, image/jpeg, image/gif" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <p id="coverImageFileNameDisplay" class="text-sm text-gray-600 mt-1"></p>
                        <img id="uploadedCoverPreview" src="" alt="Uploaded Cover Preview" class="mt-4 max-w-xs h-auto rounded-lg shadow-md" style="display:none;">
                    </div>
                    <div>
                        <label for="pdfFile" class="block text-gray-700 text-sm font-semibold mb-2" data-lang-key="uploadPdfFileLabel">Upload PDF File:</label>
                        <input type="file" id="pdfFile" accept=".pdf" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <p id="pdfFileNameDisplay" class="text-sm text-gray-600 mt-1"></p>
                    </div>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                        <button type="submit" id="submitBookBtn" class="w-full sm:w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 rounded-lg shadow-md transition duration-300 transform hover:scale-105" data-lang-key="addPublicationButton">Add Publication</button>
                        <button type="button" id="cancelEditBtn" class="w-full sm:w-1/2 bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 rounded-lg shadow-md transition duration-300 transform hover:scale-105 hidden" data-lang-key="cancelEditButton">Cancel Edit</button>
                    </div>
                </form>
            </div>

            <!-- Existing Publications List -->
            <div class="p-6 border border-gray-200 rounded-xl shadow-sm">
                <h3 class="text-2xl font-bold mb-4 text-gray-800" data-lang-key="existingPublicationsTitle">Existing Publications</h3>
                <div id="adminBooksList" class="space-y-4">
                    <!-- Books will be loaded here for admin by JavaScript -->
                    <p class="text-center text-gray-500" id="noAdminBooksMessage" data-lang-key="noPublicationsUploadedYet">No publications uploaded yet.</p>
                </div>
            </div>
        </section>

    </main>

    <!-- Footer -->
    <footer class="bg-stone-800 text-neutral-100 py-4 mt-8 px-6 md:px-8">
        <div class="container text-center text-sm">
            <p>&copy; <span id="currentYear"></span> <span data-lang-key="footerCopyright">L'Erma di Bretschneider. All rights reserved.</span></p>
            <p class="text-neutral-300" data-lang-key="footerDataStorage">Website data is stored securely using Firebase services.</p>
            <p class="text-neutral-300" data-lang-key="footerUserId">Logged in User ID: <span id="currentUserId" class="font-mono"></span></p>
        </div>
    </footer>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, /* signInAnonymously, */ onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, doc, updateDoc, deleteDoc, onSnapshot, query, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // Your actual web app's Firebase configuration
        // This MUST be replaced with YOUR unique config from Firebase Console -> Project settings -> Your apps -> Web app
        const firebaseConfig = {
            apiKey: "AIzaSyDy3cgr5QWdZ_n85Kh5IyZc5nVpkrOmYQM",
            authDomain: "charlieslab-demo-site.firebaseapp.com",
            projectId: "charlieslab-demo-site",
            storageBucket: "charlieslab-demo-site.firebasestorage.app",
            messagingSenderId: "21859165806",
            appId: "1:21859165806:web:e5d12c15ded14a93ffe87f",
            measurementId: "G-ZTYJPB011E"
        };

        // Firebase Initialization
        let db;
        let auth;
        let storage; // Declare storage variable
        let userId = null;
        let isLoggedIn = false; // Simple client-side state
        let isAuthReady = false; // Flag to indicate if auth state has been checked

        // --- Translation Logic ---
        const translations = {
            en: {
                pageTitle: "Quaderni di Archeologia della Libya - Publications",
                headerTitle: "Quaderni di Archeologia della Libya",
                homeBtn: "Publications",
                aboutBtn: "About Us",
                contactBtn: "Contact Us",
                adminLoginBtn: "Admin Login",
                ourPublicationsTitle: "Our Publications",
                searchPublicationsLabel: "Search Publications",
                searchPlaceholder: "Search by title or author...",
                noPublicationsMessage: "No publications yet. Check back soon!",
                aboutTitle: "About Quaderni di Archeologia della Libya",
                aboutPara1: "Welcome to the official website for <strong>Quaderni di Archeologia della Libya</strong>, a prestigious academic journal dedicated to archaeological research in Libya. Initiated in 1950, this esteemed series documents the significant contributions of Italian archaeological missions in the region, fostering a deeper understanding of its rich ancient history.",
                aboutPara2: "After a brief hiatus, the journal proudly resumed publication in 2018 with a new series, re-establishing itself as a leading scientific platform. We provide an essential venue for scholars interested in the archaeology and history of Libya and the broader Maghreb, ensuring high-quality, peer-reviewed content.",
                aboutPara3: "Our volumes embrace a multidisciplinary approach, featuring articles on epigraphy, ancient and colonial history, the history of archaeology, and territorial studies. Contributions are published in major European languages, complemented by comprehensive English and Arabic abstracts, to promote international academic exchange and collaboration.",
                aboutPara4: "This website serves as a dedicated resource for the series, maintained by L'Erma di Bretschneider, a renowned academic publishing house in Rome. We are committed to upholding the highest standards of scholarly excellence and ensuring the continued global dissemination of groundbreaking research presented in the \"Quaderni di Archeologia della Libya.\"",
                contactTitle: "Contact Us",
                contactEmailLabel: "Email:",
                contactPhoneLabel: "Phone:",
                contactAddressLabel: "Address:",
                contactMessage: "For inquiries regarding publications of \"Quaderni di Archeologia della Libya\" or other scholarly initiatives, please feel free to reach out to L'Erma di Bretschneider through the contact information provided above.",
                adminLoginTitle: "Admin Login",
                usernameLabel: "Username (Email):",
                passwordLabel: "Password:",
                loginButton: "Login",
                firebaseAuthHint: "Use your Firebase Auth admin email and password.",
                adminDashboardTitle: "Admin Dashboard",
                logoutButton: "Logout",
                uploadNewPublicationTitle: "Upload New Publication",
                bookTitleLabel: "Title:",
                bookAuthorLabel: "Author:",
                bookDescriptionLabel: "Description:",
                uploadCoverImageLabel: "Upload Cover Image:",
                uploadPdfFileLabel: "Upload PDF File:",
                addPublicationButton: "Add Publication",
                cancelEditButton: "Cancel Edit",
                existingPublicationsTitle: "Existing Publications",
                noPublicationsUploadedYet: "No publications uploaded yet.",
                footerCopyright: "L'Erma di Bretschneider. All rights reserved.",
                footerDataStorage: "Website data is stored securely using Firebase services.",
                footerUserId: "Logged in User ID:",
                // Modals
                modalOkBtn: "OK",
                confirmYesBtn: "Yes",
                confirmNoBtn: "No",
                msgFillTitleAuthor: "Please fill in at least the title and author.",
                msgCoverUploaded: "Cover image uploaded to Storage successfully!",
                msgPdfUploaded: "PDF uploaded to Storage successfully!",
                msgPublicationUpdated: "Publication updated successfully!",
                msgPublicationAdded: "Publication added successfully!",
                msgFirebaseStorageRules: "Ensure Firebase Storage rules allow writing.",
                msgBookNotFound: "Book not found for editing.",
                msgErrorLoadingBook: "Error loading book for editing. Please try again.",
                msgConfirmDelete: "Are you sure you want to delete this publication?",
                msgPublicationDeleted: "Publication deleted successfully!",
                msgErrorDeletingPublication: "Error deleting publication. Ensure Firebase Storage rules allow deletion.",
                msgPdfNotAvailable: "PDF not available for this book.",
                msgCurrentCover: "Current:",
                msgNoCurrentCover: "No current cover.",
                msgCurrentPdf: "Current:",
                msgNoCurrentPdf: "No current PDF.",
                msgUpdating: "Updating...",
                msgAdding: "Adding...",
                msgAuthWarning: "No user is authenticated. Public view features requiring authentication may not work.",
                msgNoBooksFoundSearch: "No publications found matching your search. Try a different term.",
                msgErrorLoadingPublications: "Error loading publications. Please try again later.",
                msgErrorLoadingAdminPublications: "Error loading publications for admin. Please try again.",
                msgLoginInvalid: "Invalid email or password.",
                msgLoginTooManyAttempts: "Too many login attempts. Please try again later.",
                msgLoginFailedGeneric: "Login failed: ",
                msgLoggedOut: "Logged out successfully.",
                msgErrorLoggingOut: "Error logging out. Please try again.",
                msgFirebaseConfigInvalid: "Firebase configuration is missing or invalid. Please ensure the app is running in a Firebase-enabled environment with correct config.",
                msgFirebaseInitFailed: "Failed to initialize Firebase. Check console for details.",
                msgPublicContentAuthRequired: "Please log in or enable anonymous access in Firebase for public content.",
                msgSelected: "Selected",
                downloadPdfButton: "Download PDF",
                editButton: "Edit",
                deleteButton: "Delete",
                byAuthor: "by",
                msgNotAvailable: "Not available",
                msgUploading: "Uploading",
                msgUploaded: "Uploaded",
                msgFailedUploadCover: "Failed to upload cover image",
                msgFailedUploadPdf: "Failed to upload PDF",
                msgCheckStorageRulesOrNetwork: "Check storage rules or network.",
                msgUploadFailed: "Upload failed.",
                msgLoginRequiredForUpload: "Please log in as admin before uploading files.",
                msgLoginRequiredToAddEdit: "You must be logged in as an admin to add/edit publications.",
                msgFirebaseNotReady: "Firebase not ready. Please wait a moment.",
                msgSelectPdfWaitUpload: "Please select a PDF file and wait for it to finish uploading.",
                msgSelectCoverWaitUpload: "Please upload a cover image and wait for it to finish uploading.",
                msgPdfMissing: "PDF missing. Please upload a PDF or ensure existing one is valid.",
                msgCoverMissing: "Cover image missing. Please upload a cover image or ensure existing one is valid.",
                msgErrorSavingPublication: "Error saving publication",
                msgCheckFirestoreRules: "Check Firestore rules.",
                editPublicationTitle: "Edit Publication",
                updatePublicationButton: "Update Publication",
                msgNoCoverSelected: "No cover image selected.",
                msgNoPdfSelected: "No PDF file selected.",
                msgEditCancelled: "Edit cancelled.",
                msgLoginRequiredToDelete: "You must be logged in as an admin to delete publications.",
                msgNoDescriptionProvided: "No description provided.",
                msgLoginRequiredToEdit: "You must be logged in as an admin to edit publications."
            },
            it: {
                pageTitle: "Quaderni di Archeologia della Libya - Pubblicazioni",
                headerTitle: "Quaderni di Archeologia della Libya",
                homeBtn: "Pubblicazioni",
                aboutBtn: "Chi Siamo",
                contactBtn: "Contattaci",
                adminLoginBtn: "Accesso Admin",
                ourPublicationsTitle: "Le Nostre Pubblicazioni",
                searchPublicationsLabel: "Cerca Pubblicazioni",
                searchPlaceholder: "Cerca per titolo o autore...",
                noPublicationsMessage: "Nessuna pubblicazione ancora. Torna presto!",
                aboutTitle: "Chi Siamo Quaderni di Archeologia della Libya",
                aboutPara1: "Benvenuti nel sito ufficiale dei <strong>Quaderni di Archeologia della Libya</strong>, una prestigiosa rivista accademica dedicata alla ricerca archeologica in Libia. Iniziata nel 1950, questa stimata serie documenta i significativi contributi delle missioni archeologiche italiane nella regione, promuovendo una comprensione più approfondita della sua ricca storia antica.",
                aboutPara2: "Dopo una breve interruzione, la rivista ha ripreso con orgoglio la pubblicazione nel 2018 con una nuova serie, ristabilendosi come una delle principali piattaforme scientifiche. Offriamo una sede essenziale per gli studiosi interessati all'archeologia e alla storia della Libia e del Maghreb, garantendo contenuti di alta qualità e sottoposti a revisione paritaria.",
                aboutPara3: "I nostri volumi adottano un approccio multidisciplinare, presentando articoli su epigrafia, storia antica e coloniale, storia dell'archeologia e studi territoriali. I contributi sono pubblicati nelle principali lingue europee, integrati da abstract completi in inglese e arabo, per promuovere lo scambio e la collaborazione accademica internazionale.",
                aboutPara4: "Questo sito web funge da risorsa dedicata alla serie, gestito da L'Erma di Bretschneider, una rinomata casa editrice accademica di Roma. Ci impegniamo a mantenere i più alti standard di eccellenza accademica e a garantire la continua diffusione globale delle ricerche innovative presentate nei \"Quaderni di Archeologia della Libya.\"",
                contactTitle: "Contattaci",
                contactEmailLabel: "Email:",
                contactPhoneLabel: "Telefono:",
                contactAddressLabel: "Indirizzo:",
                contactMessage: "Per domande relative alle pubblicazioni di \"Quaderni di Archeologia della Libya\" o ad altre iniziative accademiche, non esitate a contattare L'Erma di Bretschneider tramite le informazioni di contatto fornite sopra.",
                adminLoginTitle: "Accesso Admin",
                usernameLabel: "Nome Utente (Email):",
                passwordLabel: "Password:",
                loginButton: "Accedi",
                firebaseAuthHint: "Usa l'email e la password dell'amministratore di Firebase Auth.",
                adminDashboardTitle: "Dashboard Admin",
                logoutButton: "Esci",
                uploadNewPublicationTitle: "Carica Nuova Pubblicazione",
                bookTitleLabel: "Titolo:",
                bookAuthorLabel: "Autore:",
                bookDescriptionLabel: "Descrizione:",
                uploadCoverImageLabel: "Carica Immagine Copertina:",
                uploadPdfFileLabel: "Carica File PDF:",
                addPublicationButton: "Aggiungi Pubblicazione",
                cancelEditButton: "Annulla Modifica",
                existingPublicationsTitle: "Pubblicazioni Esistenti",
                noPublicationsUploadedYet: "Nessuna pubblicazione caricata ancora.",
                footerCopyright: "L'Erma di Bretschneider. Tutti i diritti riservati.",
                footerDataStorage: "I dati del sito web sono archiviati in modo sicuro utilizzando i servizi Firebase.",
                footerUserId: "ID Utente Connesso:",
                // Modals
                modalOkBtn: "OK",
                confirmYesBtn: "Sì",
                confirmNoBtn: "No",
                msgFillTitleAuthor: "Si prega di compilare almeno il titolo e l'autore.",
                msgCoverUploaded: "Immagine di copertina caricata con successo su Storage!",
                msgPdfUploaded: "PDF caricato con successo su Storage!",
                msgPublicationUpdated: "Pubblicazione aggiornata con successo!",
                msgPublicationAdded: "Pubblicazione aggiunta con successo!",
                msgFirebaseStorageRules: "Assicurati che le regole di Firebase Storage consentano la scrittura.",
                msgBookNotFound: "Libro non trovato per la modifica.",
                msgErrorLoadingBook: "Errore durante il caricamento del libro per la modifica. Riprova.",
                msgConfirmDelete: "Sei sicuro di voler eliminare questa pubblicazione?",
                msgPublicationDeleted: "Pubblicazione eliminata con successo!",
                msgErrorDeletingPublication: "Errore durante l'eliminazione della pubblicazione. Assicurati che le regole di Firebase Storage consentano l'eliminazione.",
                msgPdfNotAvailable: "PDF non disponibile per questo libro.",
                msgCurrentCover: "Attuale:",
                msgNoCurrentCover: "Nessuna copertina attuale.",
                msgCurrentPdf: "Attuale:",
                msgNoCurrentPdf: "Nessun PDF attuale.",
                msgUpdating: "Aggiornamento in corso...",
                msgAdding: "Aggiunta in corso...",
                msgAuthWarning: "Nessun utente è autenticato. Le funzionalità di visualizzazione pubblica che richiedono autenticazione potrebbero non funzionare.",
                msgNoBooksFoundSearch: "Nessuna pubblicazione trovata corrispondente alla tua ricerca. Prova un termine diverso.",
                msgErrorLoadingPublications: "Errore durante il caricamento delle pubblicazioni. Riprova più tardi.",
                msgErrorLoadingAdminPublications: "Errore durante il caricamento delle pubblicazioni per l'amministratore. Riprova.",
                msgLoginInvalid: "Email o password non validi.",
                msgLoginTooManyAttempts: "Troppi tentativi di accesso. Riprova più tardi.",
                msgLoginFailedGeneric: "Accesso fallito: ",
                msgLoggedOut: "Disconnesso con successo.",
                msgErrorLoggingOut: "Errore durante la disconnessione. Riprova.",
                msgFirebaseConfigInvalid: "La configurazione di Firebase è vuota o non valida. Assicurati che l'app sia in esecuzione in un ambiente abilitato a Firebase con una configurazione corretta.",
                msgFirebaseInitFailed: "Impossibile inizializzare Firebase. Controlla la console per i dettagli.",
                msgPublicContentAuthRequired: "Si prega di accedere o abilitare l'accesso anonimo in Firebase per il contenuto pubblico.",
                msgSelected: "Selezionato",
                downloadPdfButton: "Scarica PDF",
                editButton: "Modifica",
                deleteButton: "Elimina",
                byAuthor: "di",
                msgNotAvailable: "Non disponibile",
                msgUploading: "Caricamento in corso",
                msgUploaded: "Caricato",
                msgFailedUploadCover: "Caricamento immagine di copertina fallito",
                msgFailedUploadPdf: "Caricamento PDF fallito",
                msgCheckStorageRulesOrNetwork: "Controlla le regole di storage o la rete.",
                msgUploadFailed: "Caricamento fallito.",
                msgLoginRequiredForUpload: "Accedi come amministratore prima di caricare file.",
                msgLoginRequiredToAddEdit: "Devi essere loggato come amministratore per aggiungere/modificare pubblicazioni.",
                msgFirebaseNotReady: "Firebase non pronto. Attendi un momento.",
                msgSelectPdfWaitUpload: "Seleziona un file PDF e attendi che finisca il caricamento.",
                msgSelectCoverWaitUpload: "Carica un'immagine di copertina e attendi che finisca il caricamento.",
                msgPdfMissing: "PDF mancante. Carica un PDF o assicurati che quello esistente sia valido.",
                msgCoverMissing: "Immagine di copertina mancante. Carica un'immagine di copertina o assicurati che quella esistente sia valida.",
                msgErrorSavingPublication: "Errore durante il salvataggio della pubblicazione",
                msgCheckFirestoreRules: "Controlla le regole di Firestore.",
                editPublicationTitle: "Modifica Pubblicazione",
                updatePublicationButton: "Aggiorna Pubblicazione",
                msgNoCoverSelected: "Nessuna immagine di copertina selezionata.",
                msgNoPdfSelected: "Nessun file PDF selezionato.",
                msgEditCancelled: "Modifica annullata.",
                msgLoginRequiredToDelete: "Devi essere loggato come amministratore per eliminare pubblicazioni.",
                msgNoDescriptionProvided: "Nessuna descrizione fornita.",
                msgLoginRequiredToEdit: "Devi essere loggato come amministratore per modificare le pubblicazioni."
            }
        };

        let currentLang = localStorage.getItem('lang') || 'en'; // Default to English or saved preference

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.documentElement.lang = lang; // Set HTML lang attribute
            
            // Update all elements with data-lang-key
            document.querySelectorAll('[data-lang-key]').forEach(element => {
                const key = element.getAttribute('data-lang-key');
                if (translations[lang] && translations[lang][key]) {
                    // Handle innerHTML for bold tags in paragraphs
                    if (element.tagName === 'P' && (key.includes('Para') || key.includes('Subtitle'))) {
                        element.innerHTML = translations[lang][key];
                    } else {
                        element.textContent = translations[lang][key];
                    }
                }
            });

            // Update specific placeholders manually as textContent doesn't work for them
            const publicSearchInput = document.getElementById('publicSearchInput');
            if (publicSearchInput) {
                publicSearchInput.placeholder = translations[lang]['searchPlaceholder'];
            }
            
            // Update button texts that change based on context (Add/Update)
            // Ensure submitBookBtn is defined before accessing it
            const submitBookBtnLocal = document.getElementById('submitBookBtn');
            if (submitBookBtnLocal) {
                if (editingBookId) {
                    submitBookBtnLocal.textContent = translations[lang]['msgUpdating'];
                } else {
                    submitBookBtnLocal.textContent = translations[lang]['addPublicationButton'];
                }
            }

            // Update modal buttons if they are visible
            const modalOkBtn = document.querySelector('#messageModal button');
            if (modalOkBtn) modalOkBtn.textContent = translations[lang]['modalOkBtn'];

            const confirmYesBtn = document.getElementById('confirmYesBtn');
            if (confirmYesBtn) confirmYesBtn.textContent = translations[lang]['confirmYesBtn'];
            const confirmNoBtn = document.getElementById('confirmNoBtn');
            if (confirmNoBtn) confirmNoBtn.textContent = translations[lang]['confirmNoBtn'];

            // Update dynamically generated text in file input displays
            const coverImageFileNameDisplayLocal = document.getElementById('coverImageFileNameDisplay');
            const pdfFileNameDisplayLocal = document.getElementById('coverImageFileNameDisplay'); // Corrected to pdfFileNameDisplayLocal
            const uploadedCoverPreviewLocal = document.getElementById('uploadedCoverPreview');


            if (currentCoverImageFile) {
                if (coverImageFileNameDisplayLocal) coverImageFileNameDisplayLocal.textContent = `${translations[currentLang]['msgSelected']}: ${getOriginalFileNameFromUnique(currentCoverImageFile.name)}`;
            } else if (editingBookId && currentCoverImageFileName) { // Changed to use currentCoverImageFileName
                if (coverImageFileNameDisplayLocal) coverImageFileNameDisplayLocal.textContent = `${translations[currentLang]['msgCurrentCover']}: ${getOriginalFileNameFromUnique(currentCoverImageFileName)}`;
            } else {
                if (coverImageFileNameDisplayLocal) coverImageFileNameDisplayLocal.textContent = '';
            }

            if (currentPdfFile) {
                if (pdfFileNameDisplayLocal) pdfFileNameDisplayLocal.textContent = `${translations[currentLang]['msgSelected']}: ${getOriginalFileNameFromUnique(currentPdfFile.name)}`;
            } else if (editingBookId && currentPdfFileName) { // Changed to use currentPdfFileName
                if (pdfFileNameDisplayLocal) pdfFileNameDisplayLocal.textContent = `${translations[currentLang]['msgCurrentPdf']}: ${getOriginalFileNameFromUnique(currentPdfFileName)}`;
            } else {
                if (pdfFileNameDisplayLocal) pdfFileNameDisplayLocal.textContent = '';
            }

            // Update potentially dynamic content like "by Author"
            document.querySelectorAll('.book-card-author').forEach(el => {
                const author = el.dataset.author; // Assuming you add data-author attribute later if needed
                el.textContent = `${translations[currentLang]['byAuthor']} ${author}`;
            });
            // Update the no data messages if they are currently visible
            const homeViewLocal = document.getElementById('homeView');
            const noBooksMessageElement = document.getElementById('noBooksMessage');
            if (homeViewLocal && (homeViewLocal.classList.contains('flex') || !homeViewLocal.classList.contains('hidden'))) {
                if (noBooksMessageElement && !noBooksMessageElement.classList.contains('hidden')) {
                    noBooksMessageElement.textContent = translations[currentLang]['noPublicationsMessage'];
                }
            }
            const adminDashboardViewLocal = document.getElementById('adminDashboardView');
            const noAdminBooksMessage = document.getElementById('noAdminBooksMessage');
            if (adminDashboardViewLocal && (adminDashboardViewLocal.classList.contains('flex') || !adminDashboardViewLocal.classList.contains('hidden'))) {
                if (noAdminBooksMessage && !noAdminBooksMessage.classList.contains('hidden')) {
                    noAdminBooksMessage.textContent = translations[currentLang]['noPublicationsUploadedYet'];
                }
            }
        }

        // Event listeners for language buttons
        // Assigned directly as these are in the header and always available
        document.getElementById('langEnBtn').addEventListener('click', () => setLanguage('en'));
        document.getElementById('langItBtn').addEventListener('click', () => setLanguage('it'));

        // Message Modal Functions
        function showMessageModal(messageKey) {
            const message = translations[currentLang][messageKey] || messageKey; // Get translated message
            const modalMessageElement = document.getElementById('modalMessage');
            const messageModal = document.getElementById('messageModal');

            if (modalMessageElement) modalMessageElement.textContent = message;
            if (messageModal) {
                messageModal.classList.remove('hidden');
                messageModal.classList.add('flex'); // Show modal by applying flex
            }
            // Add event listener to close button inside the modal
            const closeBtn = messageModal.querySelector('.close-button');
            if (closeBtn) {
                closeBtn.onclick = closeMessageModal;
            }
        }

        function closeMessageModal() {
            const messageModal = document.getElementById('messageModal');
            const modalMessageElement = document.getElementById('modalMessage');

            if (modalMessageElement) modalMessageElement.textContent = ''; // Clear message
            if (messageModal) {
                messageModal.classList.remove('flex'); // Hide modal by removing flex
                messageModal.classList.add('hidden');
            }
        }

        // Confirmation Modal Functions
        let confirmCallback = null; // Stores the callback for the confirm modal

        function showConfirmModal(messageKey, callback) {
            const message = translations[currentLang][messageKey] || messageKey; // Get translated message
            const confirmMessageElement = document.getElementById('confirmMessage');
            const confirmModal = document.getElementById('confirmModal');

            if (confirmMessageElement) confirmMessageElement.textContent = message;
            if (confirmModal) {
                confirmModal.classList.remove('hidden');
                confirmModal.classList.add('flex');
            }
            confirmCallback = callback;
        }

        document.getElementById('confirmYesBtn').addEventListener('click', () => {
            const confirmModal = document.getElementById('confirmModal');
            if (confirmModal) {
                confirmModal.classList.remove('flex');
                confirmModal.classList.add('hidden');
            }
            if (confirmCallback) {
                confirmCallback(true);
                confirmCallback = null;
            }
        });

        document.getElementById('confirmNoBtn').addEventListener('click', () => {
            const confirmModal = document.getElementById('confirmModal');
            if (confirmModal) {
                confirmModal.classList.remove('flex');
                confirmModal.classList.add('hidden');
            }
            if (confirmCallback) {
                confirmCallback(false);
                confirmCallback = null;
            }
        });

        // Book Details Modal Functions
        function showBookDetailsModal(book) {
            const modalBookCover = document.getElementById('modalBookCover');
            const modalBookTitle = document.getElementById('modalBookTitle');
            const modalBookAuthor = document.getElementById('modalBookAuthor');
            const modalBookDescription = document.getElementById('modalBookDescription');
            const modalDownloadPdfBtn = document.getElementById('modalDownloadPdfBtn');
            const bookDetailsModal = document.getElementById('bookDetailsModal');

            if (modalBookCover) modalBookCover.src = book.coverImageUrl || 'https://placehold.co/150x200/cccccc/333333?text=No+Cover';
            if (modalBookTitle) modalBookTitle.textContent = book.title;
            if (modalBookAuthor) modalBookAuthor.textContent = `${translations[currentLang]['byAuthor']} ${book.author}`;
            if (modalBookDescription) modalBookDescription.textContent = book.description || translations[currentLang]['msgNoDescriptionProvided'];
            
            if (modalDownloadPdfBtn) {
                if (book.pdfUrl) {
                    modalDownloadPdfBtn.href = book.pdfUrl;
                    modalDownloadPdfBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    modalDownloadPdfBtn.onclick = null; // Remove previous onclick
                } else {
                    modalDownloadPdfBtn.href = '#';
                    modalDownloadPdfBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    modalDownloadPdfBtn.onclick = (e) => {
                        e.preventDefault();
                        showMessageModal('msgPdfNotAvailable');
                    };
                }
            }

            if (bookDetailsModal) {
                bookDetailsModal.classList.remove('hidden');
                bookDetailsModal.classList.add('flex');
            }
            // Add event listener to close button inside the modal
            const closeBtn = bookDetailsModal.querySelector('.close-button');
            if (closeBtn) {
                closeBtn.onclick = closeBookDetailsModal;
            }
        }

        function closeBookDetailsModal() {
            const bookDetailsModal = document.getElementById('bookDetailsModal');
            if (bookDetailsModal) {
                bookDetailsModal.classList.remove('flex');
                bookDetailsModal.classList.add('hidden');
            }
        }


        // Firebase Initialization and Authentication state management
        async function initializeFirebase() {
            try {
                // Get the existing app instance or initialize a new one if none exists
                const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
                
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app); // Initialize Firebase Storage here!

                // This listener ensures that setupEventListeners runs ONLY after auth state is determined.
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with user ID:", userId);
                        isLoggedIn = true; // Set isLoggedIn here based on actual auth state
                    } else {
                        console.warn(translations[currentLang]['msgAuthWarning']);
                        userId = null;
                        isLoggedIn = false; // Set isLoggedIn here
                    }
                    isAuthReady = true; // Auth state has been checked

                    // Now that auth is ready, set up event listeners and initial view.
                    setupEventListeners(); // CALL setupEventListeners here
                    
                    const currentUserIdElement = document.getElementById('currentUserId');
                    if (currentUserIdElement) {
                        currentUserIdElement.textContent = userId || translations[currentLang]['footerUserId'] + ' ' + translations[currentLang]['msgNotAvailable'];
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showMessageModal("msgFirebaseInitFailed");
            }
        }

        // --- View Management ---
        // Variables for views and buttons - these will be assigned inside setupEventListeners
        // Declared as `null` initially to ensure they are assigned later.
        let homeView = null, aboutView = null, contactView = null, adminLoginView = null, adminDashboardView = null;
        let homeViewBtn = null, aboutViewBtn = null, contactViewBtn = null, adminLoginBtn = null, adminLogoutBtn = null;
        let publicSearchInput = null;
        let adminLoginForm = null, usernameInput = null, passwordInput = null, loginErrorMessage = null;
        let uploadBookForm = null, bookTitleInput = null, bookAuthorInput = null, bookDescriptionInput = null, coverImageFileInput = null, coverImageFileNameDisplay = null, uploadedCoverPreview = null, pdfFileInput = null, pdfFileNameDisplay = null, submitBookBtn = null, cancelEditBtn = null, formTitle = null;
        let adminBooksList = null, noAdminBooksMessage = null, noBooksMessage = null, booksContainer = null;

        function showView(viewId) {
            // All these variables should be assigned in setupEventListeners, which runs once auth is ready.
            const allViews = [homeView, aboutView, contactView, adminLoginView, adminDashboardView];
            allViews.forEach(view => {
                if (view) {
                    view.classList.remove('flex');
                    view.classList.add('hidden');
                }
            });

            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.remove('hidden');
                targetView.classList.add('flex');
            }

            if (viewId === 'homeView') {
                if (userId) {
                    loadBooks();
                } else {
                    if (booksContainer && noBooksMessage) {
                        booksContainer.innerHTML = '';
                        noBooksMessage.textContent = translations[currentLang]['msgPublicContentAuthRequired'];
                        noBooksMessage.classList.remove('hidden');
                    }
                }
            } else if (viewId === 'adminDashboardView' && isLoggedIn) {
                loadBooksForAdmin();
            }
            setLanguage(currentLang); // Reapply translations after view change
        }

        // Function to set up all event listeners and initial view after DOM is ready AND Firebase Auth is ready
        function setupEventListeners() {
            // Assign ALL DOM elements to variables here
            homeView = document.getElementById('homeView');
            aboutView = document.getElementById('aboutView');
            contactView = document.getElementById('contactView');
            adminLoginView = document.getElementById('adminLoginView');
            adminDashboardView = document.getElementById('adminDashboardView');

            homeViewBtn = document.getElementById('homeViewBtn');
            aboutViewBtn = document.getElementById('aboutViewBtn');
            contactViewBtn = document.getElementById('contactViewBtn');
            adminLoginBtn = document.getElementById('adminLoginBtn');
            adminLogoutBtn = document.getElementById('adminLogoutBtn');
            
            publicSearchInput = document.getElementById('publicSearchInput');

            adminLoginForm = document.getElementById('adminLoginForm');
            usernameInput = document.getElementById('username');
            passwordInput = document.getElementById('password');
            loginErrorMessage = document.getElementById('loginErrorMessage');

            uploadBookForm = document.getElementById('uploadBookForm');
            bookTitleInput = document.getElementById('bookTitle');
            bookAuthorInput = document.getElementById('bookAuthor');
            bookDescriptionInput = document.getElementById('bookDescription');
            coverImageFileInput = document.getElementById('coverImageFile');
            coverImageFileNameDisplay = document.getElementById('coverImageFileNameDisplay');
            uploadedCoverPreview = document.getElementById('uploadedCoverPreview');
            pdfFileInput = document.getElementById('pdfFile');
            pdfFileNameDisplay = document.getElementById('pdfFileNameDisplay');
            submitBookBtn = document.getElementById('submitBookBtn');
            cancelEditBtn = document.getElementById('cancelEditBtn');
            formTitle = document.getElementById('formTitle');
            adminBooksList = document.getElementById('adminBooksList');
            noAdminBooksMessage = document.getElementById('noAdminBooksMessage');
            noBooksMessage = document.getElementById('noBooksMessage');
            booksContainer = document.getElementById('booksContainer');

            // Set initial language and display home view
            setLanguage(currentLang); // Apply initial translations
            showView('homeView'); // Show the first view, which will trigger loadBooks

            // Attach Event Listeners for Navigation
            if (homeViewBtn) homeViewBtn.addEventListener('click', () => showView('homeView'));
            if (aboutViewBtn) aboutViewBtn.addEventListener('click', () => showView('aboutView'));
            if (contactViewBtn) contactViewBtn.addEventListener('click', () => showView('contactView'));
            if (adminLoginBtn) adminLoginBtn.addEventListener('click', () => showView('adminLoginView'));
            
            // The exploreBooksBtn was removed from HTML, so its listener is no longer needed.

            if (adminLogoutBtn) {
                adminLogoutBtn.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        isLoggedIn = false;
                        showView('homeView');
                        showMessageModal("msgLoggedOut");
                    } catch (error) {
                        console.error("Error signing out:", error);
                        showMessageModal("msgErrorLoggingOut");
                    }
                });
            }

            // Admin Login Form Listener
            if (adminLoginForm) {
                adminLoginForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const email = usernameInput.value;
                    const password = passwordInput.value;

                    try {
                        await signInWithEmailAndPassword(auth, email, password);
                        isLoggedIn = true;
                        showView('adminDashboardView');
                        if (loginErrorMessage) loginErrorMessage.textContent = '';
                        if (usernameInput) usernameInput.value = '';
                        if (passwordInput) passwordInput.value = '';
                        loadBooksForAdmin();
                    } catch (error) {
                        console.error("Firebase Login Error:", error.code, error.message);
                        if (loginErrorMessage) {
                            if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                                loginErrorMessage.textContent = translations[currentLang]['msgLoginInvalid'];
                            } else if (error.code === 'auth/too-many-requests') {
                                loginErrorMessage.textContent = translations[currentLang]['msgLoginTooManyAttempts'];
                            } else {
                                loginErrorMessage.textContent = translations[currentLang]['msgLoginFailedGeneric'] + error.message;
                            }
                        }
                    }
                });
            }

            // File input change listeners
            if (coverImageFileInput) {
                coverImageFileInput.addEventListener('change', async (e) => {
                    if (!isLoggedIn) {
                        showMessageModal("msgLoginRequiredForUpload");
                        e.target.value = ''; // Clear selection
                        return;
                    }
                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        // Store the full unique filename including timestamp for later deletion/reference
                        const uniqueFileName = `${Date.now()}_${file.name}`;
                        currentCoverImageFile = file; // Store the actual file object for form reset
                        currentCoverImageFileName = uniqueFileName; // Store the unique name

                        // Display a loading message
                        if(uploadedCoverPreview) {
                            uploadedCoverPreview.src = ''; // Clear preview
                            uploadedCoverPreview.style.display = 'none';
                        }
                        if(coverImageFileNameDisplay) coverImageFileNameDisplay.textContent = `${translations[currentLang]['msgUploading']} ${file.name}...`;

                        // Upload to Firebase Storage using the unique filename
                        const imageStorageRef = ref(storage, `artifacts/${firebaseConfig.projectId}/public/files/covers/${uniqueFileName}`);
                        try {
                            const snapshot = await uploadBytes(imageStorageRef, file);
                            currentCoverImageURL = await getDownloadURL(snapshot.ref);
                            if(uploadedCoverPreview) {
                                uploadedCoverPreview.src = currentCoverImageURL;
                                uploadedCoverPreview.style.display = 'block';
                            }
                            if(coverImageFileNameDisplay) coverImageFileNameDisplay.textContent = `${translations[currentLang]['msgUploaded']}: ${file.name}`; // Display original filename
                            showMessageModal("msgCoverUploaded");
                        } catch (error) {
                            console.error("Error uploading cover image to Firebase Storage:", error);
                            showMessageModal(`${translations[currentLang]['msgFailedUploadCover']}: ${error.message}. ${translations[currentLang]['msgCheckStorageRulesOrNetwork']}`);
                            currentCoverImageFile = null; // Reset file object
                            currentCoverImageFileName = '';
                            if(coverImageFileNameDisplay) coverImageFileNameDisplay.textContent = translations[currentLang]['msgUploadFailed'];
                            if(uploadedCoverPreview) {
                                uploadedCoverPreview.style.display = 'none';
                                uploadedCoverPreview.src = '';
                            }
                        }
                    } else {
                        currentCoverImageFile = null;
                        currentCoverImageFileName = '';
                        if(coverImageFileNameDisplay) coverImageFileNameDisplay.textContent = '';
                        currentCoverImageURL = '';
                        if(uploadedCoverPreview) {
                            uploadedCoverPreview.src = '';
                            uploadedCoverPreview.style.display = 'none';
                        }
                    }
                });
            }

            if (pdfFileInput) {
                pdfFileInput.addEventListener('change', async (e) => {
                    if (!isLoggedIn) {
                        showMessageModal("msgLoginRequiredForUpload");
                        e.target.value = '';
                        return;
                    }
                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        // Store the full unique filename including timestamp for later deletion/reference
                        const uniqueFileName = `${Date.now()}_${file.name}`;
                        currentPdfFile = file; // Store the actual file object for form reset
                        currentPdfFileName = uniqueFileName; // Store the unique name

                        // Display a loading message
                        if(pdfFileNameDisplay) pdfFileNameDisplay.textContent = `${translations[currentLang]['msgUploading']} ${file.name}...`;

                        // Upload to Firebase Storage using the unique filename
                        const pdfStorageRef = ref(storage, `artifacts/${firebaseConfig.projectId}/public/files/pdfs/${uniqueFileName}`);
                        try {
                            const snapshot = await uploadBytes(pdfStorageRef, file);
                            currentPdfURL = await getDownloadURL(snapshot.ref);
                            if(pdfFileNameDisplay) pdfFileNameDisplay.textContent = `${translations[currentLang]['msgUploaded']}: ${file.name}`; // Display original filename
                            showMessageModal("msgPdfUploaded");
                        } catch (error) {
                            console.error("Error uploading PDF to Firebase Storage:", error);
                            showMessageModal(`${translations[currentLang]['msgFailedUploadPdf']}: ${error.message}. ${translations[currentLang]['msgCheckStorageRulesOrNetwork']}`);
                            currentPdfFile = null; // Reset file object
                            currentPdfFileName = '';
                            if(pdfFileNameDisplay) pdfFileNameDisplay.textContent = translations[currentLang]['msgUploadFailed'];
                            currentPdfURL = '';
                        }
                    } else {
                        currentPdfFile = null;
                        currentPdfFileName = '';
                        if(pdfFileNameDisplay) pdfFileNameDisplay.textContent = '';
                        currentPdfURL = '';
                    }
                });
            }

            // Upload/Edit Form Listener
            if (uploadBookForm) {
                uploadBookForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (!isLoggedIn) {
                        showMessageModal("msgLoginRequiredToAddEdit");
                        return;
                    }
                    if (!isAuthReady) {
                        showMessageModal("msgFirebaseNotReady");
                        return;
                    }

                    const title = bookTitleInput.value.trim();
                    const author = bookAuthorInput.value.trim();
                    const description = bookDescriptionInput.value.trim();

                    let pdfUrlToSave = currentPdfURL;
                    let coverImageUrlToSave = currentCoverImageURL;
                    let pdfFileNameToSave = currentPdfFileName;
                    let coverImageFileNameToSave = currentCoverImageFileName;

                    if (!title || !author) {
                        showMessageModal("msgFillTitleAuthor");
                        return;
                    }

                    if (editingBookId) {
                        const bookSnap = await getDoc(doc(db, BOOKS_COLLECTION_PATH, editingBookId));
                        const existingBook = bookSnap.exists() ? bookSnap.data() : null;

                        // If no new PDF was selected, use existing URL and unique filename from Firestore
                        if (!currentPdfFile) {
                            pdfUrlToSave = existingBook?.pdfUrl || '';
                            pdfFileNameToSave = existingBook?.pdfFileName || ''; // Use the unique filename from storage
                        }
                        // If no new cover was selected, use existing URL and unique filename from Firestore
                        if (!currentCoverImageFile) {
                            coverImageUrlToSave = existingBook?.coverImageUrl || '';
                            coverImageFileNameToSave = existingBook?.coverImageFileName || ''; // Use the unique filename from storage
                        }
                    } else { // For new books, ensure files are selected AND uploaded
                        if (!currentPdfFile || !currentPdfURL) {
                            showMessageModal("msgSelectPdfWaitUpload");
                            return;
                        }
                        if (!currentCoverImageFile || !currentCoverImageURL) {
                            showMessageModal("msgSelectCoverWaitUpload");
                            return;
                        }
                    }

                    // Final check that URLs are available after all logic
                    if (!pdfUrlToSave) {
                        showMessageModal("msgPdfMissing");
                        return;
                    }
                    if (!coverImageUrlToSave) {
                        showMessageModal("msgCoverMissing");
                        return;
                    }

                    if (submitBookBtn) {
                        submitBookBtn.textContent = editingBookId ? translations[currentLang]['msgUpdating'] : translations[currentLang]['msgAdding'];
                        submitBookBtn.disabled = true;
                    }
                    
                    try {
                        const bookData = {
                            title: title,
                            author: author,
                            description: description,
                            coverImageUrl: coverImageUrlToSave,
                            coverImageFileName: coverImageFileNameToSave, // This will now correctly store the unique name
                            pdfUrl: pdfUrlToSave,
                            pdfFileName: pdfFileNameToSave, // This will now correctly store the unique name
                            timestamp: new Date().toISOString()
                        };

                        if (editingBookId) {
                            await updateDoc(doc(db, BOOKS_COLLECTION_PATH, editingBookId), bookData);
                            showMessageModal("msgPublicationUpdated");
                        } else {
                            await addDoc(collection(db, BOOKS_COLLECTION_PATH), bookData);
                            showMessageModal("msgPublicationAdded");
                        }

                        resetBookForm();
                    } catch (error) {
                        console.error("Error saving document: ", error);
                        showMessageModal(`${translations[currentLang]['msgErrorSavingPublication']}: ${error.message}. ${translations[currentLang]['msgCheckFirestoreRules']}`);
                    } finally {
                        if (submitBookBtn) {
                            submitBookBtn.textContent = editingBookId ? translations[currentLang]['updatePublicationButton'] : translations[currentLang]['addPublicationButton'];
                            submitBookBtn.disabled = false;
                            setLanguage(currentLang);
                        }
                    }
                });
            }

            // Cancel Edit Listener
            if (cancelEditBtn) {
                cancelEditBtn.addEventListener('click', () => {
                    resetBookForm();
                    showMessageModal("msgEditCancelled");
                });
            }

            // Public Search Input Listener
            if (publicSearchInput) {
                publicSearchInput.addEventListener('input', (e) => {
                    loadBooks(e.target.value);
                });
            }

            // Modals backdrop click
            const messageModal = document.getElementById('messageModal');
            if (messageModal) {
                messageModal.addEventListener('click', function(event) {
                    if (event.target === messageModal) {
                        closeMessageModal();
                    }
                });
            }
            
            const confirmModal = document.getElementById('confirmModal');
            if (confirmModal) {
                confirmModal.addEventListener('click', function(event) {
                    if (event.target === confirmModal) {
                        confirmModal.classList.remove('flex');
                        confirmModal.classList.add('hidden');
                        if (confirmCallback) {
                            confirmCallback(false);
                            confirmCallback = null;
                        }
                    }
                });
            }

            const bookDetailsModal = document.getElementById('bookDetailsModal');
            if (bookDetailsModal) {
                bookDetailsModal.addEventListener('click', function(event) {
                    if (event.target === bookDetailsModal) {
                        closeBookDetailsModal();
                    }
                });
            }
        } // End of setupEventListeners

        // --- Book Management (Firestore) ---
        const BOOKS_COLLECTION_PATH = `artifacts/${firebaseConfig.projectId}/public/data/books`;

        // Function to load and display books in the public view
        async function loadBooks(searchTerm = '') {
            if (!isAuthReady || !userId) {
                if (noBooksMessage) {
                    noBooksMessage.innerHTML = translations[currentLang]['msgPublicContentAuthRequired'];
                    noBooksMessage.classList.remove('hidden');
                }
                if (booksContainer) {
                    booksContainer.innerHTML = '';
                }
                return;
            }

            if (!booksContainer) { console.error("booksContainer not found in loadBooks."); return; }
            if (!noBooksMessage) { console.error("noBooksMessage not found in loadBooks."); return; }

            noBooksMessage.classList.add('hidden');
            booksContainer.innerHTML = '';

            try {
                const q = query(collection(db, BOOKS_COLLECTION_PATH));
                onSnapshot(q, (querySnapshot) => {
                    let books = [];
                    querySnapshot.forEach((doc) => {
                        books.push({ id: doc.id, ...doc.data() });
                    });

                    const lowerCaseSearchTerm = searchTerm.toLowerCase();
                    const filteredBooks = books.filter(book =>
                        book.title.toLowerCase().includes(lowerCaseSearchTerm) ||
                        book.author.toLowerCase().includes(lowerCaseSearchTerm) ||
                        (book.description && book.description.toLowerCase().includes(lowerCaseSearchTerm))
                    );

                    booksContainer.innerHTML = '';
                    if (filteredBooks.length === 0) {
                        noBooksMessage.textContent = translations[currentLang]['msgNoBooksFoundSearch'];
                        noBooksMessage.classList.remove('hidden');
                        return;
                    }

                    noBooksMessage.classList.add('hidden');

                    filteredBooks.forEach((book) => {
                        // Truncate description for card view
                        const truncatedDescription = book.description && book.description.length > 150 // Increased to 150 for more lines
                            ? book.description.substring(0, 147) + '...' 
                            : (book.description || translations[currentLang]['msgNoDescriptionProvided']);

                        const bookCard = `
                            <div class="bg-neutral-100 p-4 rounded-lg shadow-md flex flex-col items-center text-center transition duration-300 hover:shadow-lg book-card" data-book-id="${book.id}">
                                <img src="${book.coverImageUrl || 'https://placehold.co/150x200/cccccc/333333?text=No+Cover'}" alt="${book.title}" class="w-36 h-48 object-cover rounded-md mb-4 shadow-sm">
                                <h3 class="text-xl font-semibold mb-2 text-gray-800">${book.title}</h3>
                                <p class="text-gray-600 text-sm mb-3">${translations[currentLang]['byAuthor']} ${book.author}</p>
                                <p class="text-gray-700 text-sm h-20 overflow-hidden">${truncatedDescription}</p> <!-- Changed h-12 to h-20 -->
                                <button class="mt-auto bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 transform hover:scale-105 mt-4" onclick="showBookDetailsModalWithId('${book.id}')" data-lang-key="viewDetailsButton">View Details</button>
                            </div>
                        `;
                        booksContainer.innerHTML += bookCard;
                    });
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for books:", error);
                showMessageModal("msgErrorLoadingPublications");
                if (noBooksMessage) {
                    noBooksMessage.textContent = translations[currentLang]['msgErrorLoadingPublications'];
                }
            }
        }

        // Function to load and display books in the admin dashboard
        async function loadBooksForAdmin() {
            if (!isAuthReady || !isLoggedIn) {
                console.warn("Not authorized to load admin books. Please log in.");
                return;
            }
            if (!adminBooksList) { console.error("adminBooksList not found in loadBooksForAdmin."); return; }
            if (!noAdminBooksMessage) { console.error("noAdminBooksMessage not found in loadBooksForAdmin."); return; }

            adminBooksList.innerHTML = '';
            noAdminBooksMessage.classList.add('hidden');

            try {
                const q = query(collection(db, BOOKS_COLLECTION_PATH));
                onSnapshot(q, (querySnapshot) => {
                    adminBooksList.innerHTML = '';
                    if (querySnapshot.empty) {
                        if (noAdminBooksMessage) {
                            noAdminBooksMessage.classList.remove('hidden');
                            noAdminBooksMessage.textContent = translations[currentLang]['noPublicationsUploadedYet'];
                        }
                        return;
                    }

                    noAdminBooksMessage.classList.add('hidden');

                    querySnapshot.forEach((docRef) => {
                        const book = docRef.data();
                        const bookId = docRef.id;
                        // Display original filename for better readability in Admin UI
                        const pdfDisplayFileName = getOriginalFileNameFromUnique(book.pdfFileName) || translations[currentLang]['msgNotAvailable'];
                        const coverDisplayFileName = getOriginalFileNameFromUnique(book.coverImageFileName) || translations[currentLang]['msgNotAvailable'];

                        const bookItem = `
                            <div class="bg-neutral-100 p-4 rounded-lg shadow-sm grid grid-cols-1 md:grid-cols-3 items-center gap-4">
                                <div class="flex items-center col-span-1 md:col-span-2">
                                    <img src="${book.coverImageUrl || 'https://placehold.co/50x60/cccccc/333333?text=Cover'}" alt="${book.title}" class="w-12 h-16 object-cover rounded-md mr-4 shadow-sm">
                                    <div>
                                        <h4 class="text-lg font-semibold text-gray-800">${book.title}</h4>
                                        <p class="text-gray-600 text-sm">${book.author}</p>
                                        <p class="text-gray-500 text-xs">${translations[currentLang]['uploadPdfFileLabel']}: ${pdfDisplayFileName}</p>
                                        <p class="text-gray-500 text-xs">${translations[currentLang]['uploadCoverImageLabel']}: ${coverDisplayFileName}</p>
                                    </div>
                                </div>
                                <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-2 justify-end">
                                    <button data-id="${bookId}" class="edit-book-btn bg-stone-500 hover:bg-stone-600 text-white py-1 px-3 rounded-lg text-sm shadow-md transition duration-300 transform hover:scale-105" data-lang-key="editButton">Edit</button>
                                    <button data-id="${bookId}" class="delete-book-btn bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded-lg text-sm shadow-md transition duration-300 transform hover:scale-105" data-lang-key="deleteButton">Delete</button>
                                </div>
                            </div>
                        `;
                        if (adminBooksList) adminBooksList.innerHTML += bookItem;
                    });

                    document.querySelectorAll('.edit-book-btn').forEach(button => {
                        button.addEventListener('click', (e) => editBook(e.target.dataset.id));
                    });
                    document.querySelectorAll('.delete-book-btn').forEach(button => {
                        button.addEventListener('click', (e) => deleteBook(e.target.dataset.id));
                    });
                    setLanguage(currentLang); // Re-apply translations for dynamically added buttons
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for admin books:", error);
                showMessageModal("msgErrorLoadingAdminPublications");
                if (noAdminBooksMessage) {
                    noAdminBooksMessage.textContent = translations[currentLang]['msgErrorLoadingAdminPublications'];
                }
            }
        }


        // --- Add/Edit Book Logic ---
        let editingBookId = null; // Stores the ID of the book being edited
        let currentCoverImageFile = null; // Stores the actual File object for upload
        let currentPdfFile = null; // Stores the actual File object for upload
        let currentCoverImageURL = ''; // Stores the Firebase Storage URL of the selected/existing cover image
        let currentCoverImageFileName = ''; // Stores the name of the selected/existing image file (includes timestamp)
        let currentPdfFileName = ''; // Stores the name of the selected/existing PDF file (includes timestamp)
        let currentPdfURL = ''; // Stores the Firebase Storage URL of the selected/existing PDF file


        // Helper to extract original file name from unique timestamped name (for display)
        function getOriginalFileNameFromUnique(uniqueFileName) {
            if (!uniqueFileName) return '';
            const parts = uniqueFileName.split('_');
            if (parts.length > 1 && !isNaN(Number(parts[0]))) { // Check if first part is a number (timestamp)
                parts.shift(); // Remove the timestamp
                return parts.join('_'); // Rejoin the rest
            }
            return uniqueFileName; // Return as is if no timestamp prefix
        }


        // --- Form Reset ---
        function resetBookForm() {
            if (uploadBookForm) uploadBookForm.reset();
            if (bookTitleInput) bookTitleInput.value = '';
            if (bookAuthorInput) bookAuthorInput.value = '';
            if (bookDescriptionInput) bookDescriptionInput.value = '';
            if (coverImageFileInput) coverImageFileInput.value = '';
            if (pdfFileInput) pdfFileInput.value = '';
            if (coverImageFileNameDisplay) coverImageFileNameDisplay.textContent = '';
            if (pdfFileNameDisplay) pdfFileNameDisplay.textContent = '';
            if (uploadedCoverPreview) {
                uploadedCoverPreview.src = '';
                uploadedCoverPreview.style.display = 'none';
            }
            if (formTitle) formTitle.textContent = translations[currentLang]['uploadNewPublicationTitle'];
            if (submitBookBtn) submitBookBtn.textContent = translations[currentLang]['addPublicationButton'];
            if (cancelEditBtn) cancelEditBtn.classList.add('hidden');
            editingBookId = null;
            currentCoverImageFile = null;
            currentPdfFile = null;
            currentCoverImageURL = '';
            currentCoverImageFileName = ''; // Reset unique filename
            currentPdfFileName = ''; // Reset unique filename
            currentPdfURL = '';
        }

        // Function to show book details in a modal given book ID
        window.showBookDetailsModalWithId = async function(bookId) {
            if (!isAuthReady) {
                showMessageModal("msgFirebaseNotReady");
                return;
            }
            try {
                const bookRef = doc(db, BOOKS_COLLECTION_PATH, bookId);
                const bookSnap = await getDoc(bookRef);

                if (bookSnap.exists()) {
                    showBookDetailsModal(bookSnap.data());
                } else {
                    showMessageModal("msgBookNotFound");
                }
            } catch (error) {
                console.error("Error fetching book for details:", error);
                showMessageModal("msgErrorLoadingBook");
            }
        };

        // --- Edit Book Logic ---
        async function editBook(bookId) {
            if (!isAuthReady || !isLoggedIn) {
                showMessageModal("msgLoginRequiredToEdit");
                return;
            }

            try {
                const bookRef = doc(db, BOOKS_COLLECTION_PATH, bookId);
                const bookSnap = await getDoc(bookRef);

                if (bookSnap.exists()) {
                    const bookData = bookSnap.data();
                    editingBookId = bookId;

                    // Populate the form with existing data
                    bookTitleInput.value = bookData.title;
                    bookAuthorInput.value = bookData.author;
                    bookDescriptionInput.value = bookData.description;

                    // Set cover image preview and currentCoverImageURL
                    uploadedCoverPreview.src = bookData.coverImageUrl || '';
                    uploadedCoverPreview.style.display = bookData.coverImageUrl ? 'block' : 'none';
                    coverImageFileInput.value = ''; // Important: Clear native file input value
                    currentCoverImageURL = bookData.coverImageUrl || ''; // Store the existing URL
                    currentCoverImageFileName = bookData.coverImageFileName || ''; // Store the unique filename from Firestore
                    coverImageFileNameDisplay.textContent = currentCoverImageFileName ? `${translations[currentLang]['msgCurrentCover']}: ${getOriginalFileNameFromUnique(currentCoverImageFileName)}` : translations[currentLang]['msgNoCoverSelected'];

                    // Set PDF display and currentPdfURL
                    pdfFileInput.value = ''; // Important: Clear native file input value
                    currentPdfURL = bookData.pdfUrl || ''; // Store the existing URL
                    currentPdfFileName = bookData.pdfFileName || ''; // Store the unique filename from Firestore
                    pdfFileNameDisplay.textContent = currentPdfFileName ? `${translations[currentLang]['msgCurrentPdf']}: ${getOriginalFileNameFromUnique(currentPdfFileName)}` : translations[currentLang]['msgNoPdfSelected'];


                    // Change form title and button text
                    formTitle.textContent = translations[currentLang]['editPublicationTitle'];
                    submitBookBtn.textContent = translations[currentLang]['updatePublicationButton'];
                    cancelEditBtn.classList.remove('hidden'); // Show cancel button

                    // Scroll to the form
                    window.scrollTo({ top: uploadBookForm.offsetTop, behavior: 'smooth' });
                } else {
                    showMessageModal("msgBookNotFound");
                }
            } catch (error) {
                console.error("Error fetching book for edit:", error);
                showMessageModal("msgErrorLoadingBook");
            }
        }


        // --- Delete Book Logic ---
        async function deleteBook(bookId) {
            if (!isLoggedIn) {
                showMessageModal("msgLoginRequiredToDelete");
                return;
            }
            if (!isAuthReady) {
                 showMessageModal("msgFirebaseNotReady");
                 return;
            }

            showConfirmModal("msgConfirmDelete", async (confirmed) => {
                if (confirmed) {
                    try {
                        const bookRef = doc(db, BOOKS_COLLECTION_PATH, bookId);
                        const bookSnap = await getDoc(bookRef);
                        const bookData = bookSnap.data();

                        // Attempt to delete files from Firebase Storage first
                        // Use the stored unique filenames to construct storage references
                        if (bookData.pdfFileName) {
                            try {
                                const pdfStorageRef = ref(storage, `artifacts/${firebaseConfig.projectId}/public/files/pdfs/${bookData.pdfFileName}`);
                                await deleteObject(pdfStorageRef);
                                console.log("PDF deleted from Storage:", bookData.pdfFileName);
                            } catch (storageError) {
                                console.warn("Could not delete PDF from Storage (might not exist or permission issue):", bookData.pdfFileName, storageError);
                                showMessageModal(`Error deleting PDF: ${storageError.message}.`);
                            }
                        }
                        if (bookData.coverImageFileName) {
                            try {
                                const coverStorageRef = ref(storage, `artifacts/${firebaseConfig.projectId}/public/files/covers/${bookData.coverImageFileName}`);
                                await deleteObject(coverStorageRef);
                                console.log("Cover image deleted from Storage:", bookData.coverImageFileName);
                            } catch (storageError) {
                                console.warn("Could not delete cover image from Storage (might not exist or permission issue):", bookData.coverImageFileName, storageError);
                                showMessageModal(`Error deleting cover image: ${storageError.message}.`);
                            }
                        }

                        // Finally, delete the document from Firestore
                        await deleteDoc(bookRef);
                        showMessageModal("msgPublicationDeleted");
                        // onSnapshot listeners will automatically update loadBooksForAdmin and loadBooks
                    } catch (error) {
                        console.error("Error removing document: ", error);
                        showMessageModal("msgErrorDeletingPublication");
                    }
                }
            });
        }

        // Initialize Firebase when the window loads
        window.onload = function() {
            initializeFirebase();
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        };
    </script>
</body>
</html>
